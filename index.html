<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coconut's Valentine Run ‚ù§Ô∏è</title>
  <style>
    html, body { 
    margin: 0; 
    height: 100%; 
    background: #0f0f14; 
    overflow: hidden; 
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
    
    /* Add this line here */
    -webkit-tap-highlight-color: transparent; 
}
    #wrap { height: 100%; display: grid; place-items: center; }
    canvas { 
    /* Your original styles */
    background: linear-gradient(#6a1b9a, #ff7043); 
    border-radius: 18px; 
    box-shadow: 0 20px 80px rgba(0,0,0,.4); 
    max-width: 100vw; 
    max-height: 100vh;
    
    /* The new mobile scaling additions */
    display: block;
    object-fit: contain; 
}
   .voucher {
    margin-top: 20px;
    background: linear-gradient(135deg, #fff3b0, #ffc107);
    border-radius: 15px;
    padding: 25px;
    color: #5d4037;
    text-align: center;
    border: 4px dashed #ffffff;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
}

/* The 3D Spinning Coin */
.coin-container {
    perspective: 1000px;
    width: 80px;
    height: 80px;
    margin: 0 auto 15px;
}

.coin-face {
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, #ffe082 20%, #ffb300 100%);
    border-radius: 50%;
    border: 5px double #ff8f00;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 40px;
    font-weight: bold;
    color: #ff8f00;
    text-shadow: 1px 1px 0px rgba(255,255,255,0.5);
    box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 5px 15px rgba(0,0,0,0.3);
    animation: spinCoin 3s infinite linear;
}

@keyframes spinCoin {
    0% { transform: rotateY(0deg); }
    100% { transform: rotateY(360deg); }
}

.voucher h2 { margin: 0; font-size: 20px; letter-spacing: 1px; color: #8e6a00; }
.voucher .amount { font-size: 48px; font-weight: 900; margin: 5px 0; color: #3e2723; }
    .hud { position: fixed; left: 16px; top: 16px; color: #fff; font-size: 14px; padding: 10px 12px; border-radius: 12px; background: rgba(255,255,255,.06); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,.08); z-index: 10; }
    .hud b { color: #ff7aa2; }
    .modal { position: fixed; inset: 0; display: flex; place-items: center; justify-content: center; padding: 24px; background: rgba(15, 15, 20, 0.9); z-index: 100; }
    .card { width: min(520px, 92vw); background: rgba(40, 30, 50, 0.95); border: 2px solid #ff4f86; border-radius: 24px; padding: 32px; color: #fff; backdrop-filter: blur(12px); box-shadow: 0 0 40px rgba(255, 79, 134, 0.3); text-align: center; }
    .card h1 { margin: 0 0 15px; font-size: 32px; color: #ff7aa2; }
    .card p { margin: 0 0 20px; font-size: 18px; line-height: 1.5; opacity: 0.9; }
    .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px; text-align: left; }
    .info-item { background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 12px; font-size: 14px; }
    .info-item b { display: block; color: #ff7aa2; margin-bottom: 4px; }
    .btn { display: inline-block; cursor: pointer; user-select: none; padding: 18px 34px; border-radius: 15px; background: #ff4f86; color: #fff; font-weight: 700; font-size: 18px; border: none; transition: all 0.2s; }
    .btn:hover { background: #ff6b9a; transform: translateY(-2px); }
    /* Scrollable letter area for the final win screen */
.letter-content {
    max-height: 250px;
    overflow-y: auto;
    text-align: left;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 12px;
    font-size: 16px;
    line-height: 1.6;
    margin-bottom: 20px;
}
/* Style the scrollbar to match the theme */
.letter-content::-webkit-scrollbar { width: 6px; }
.letter-content::-webkit-scrollbar-thumb { background: #ff4f86; border-radius: 10px; }
  </style>
</head>
<body>
  <div class="hud">
  Distance: <b id="dist">0</b> / <b id="goal">2300</b>
</div>
  <div class="modal" id="modal">
    <div class="card">
      <h1 id="modalTitle">Coconut's Valentine Run ‚ù§Ô∏è</h1>
      <p id="modalText"></p>
      <div id="infoSection" class="info-grid">
        <div class="info-item"><b>How to Play</b> Space / ‚Üë / Tap to jump. Jump over the pink blocks.</div>
        <div class="info-item"><b>Checkpoints</b> Trees turn pink and you unlock a message.</div>
        <div class="info-item"><b>The Goal</b> Reach 2300 miles. It's the distance from Carson to Chantilly!</div>
        <div class="info-item"><b>Prize</b> A mystery gift from Kyel </div>
      </div>
      <button class="btn" id="modalBtn">Start! </button>
    </div>
  </div>

  <div id="wrap"><canvas id="c" width="960" height="540"></canvas></div>

<script>
(() => {
    const password = prompt("Enter the secret code to play:");
if (password !== "bitch") { // Change this to your password
    alert("Incorrect code! Access denied.");
    document.body.innerHTML = "<h1>404 Not Found</h1>"; // Makes it look like a broken link
    return;
}
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const groundY = H - 80;
  const finishX = 18000;
  const baseSpeed = 7;

  let player, cam, hearts, fireworks, obstacles, checkpointState, paused = true, gameStarted = false;

  const CHECKPOINTS = [
    { x: 1600,  title: "Checkpoint 1 üíó", text: "Starting strong!" },
    { x: 3200,  title: "Checkpoint 2 üíû", text: "You've got a great rhythm." },
    { x: 4800,  title: "Checkpoint 3 üå∏", text: "Rolling through paradise." },
    { x: 6400,  title: "Checkpoint 4 üíò", text: "Almost halfway there!" },
    { x: 8000,  title: "Checkpoint 5 üéÄ", text: "Halfway! You're a pro at this." },
    { x: 9600,  title: "Checkpoint 6 üíù", text: "The challenge is picking up!" },
    { x: 11200, title: "Checkpoint 7 üåü", text: "11,200m! Stay focused." },
    { x: 12800, title: "Checkpoint 8 ‚ú®", text: "Final stretch! Ready for the triples?" },
    { x: 14400, title: "Checkpoint 9 ‚ù§Ô∏è", text: "The finish line is in sight!" },
  ];

  function spawnHeart(x, y) {
    fireworks.push({
      // Offset x and y so particles emerge from the lower-back area
      x: x - 10, 
      y: y + 5,
      vx: (Math.random() * 1.5 - 1), // Slightly more horizontal spread
      vy: -0.5 - Math.random() * 1,  // Slower upward drift
      life: 50,
      size: 7 + Math.random() * 6    // Reduced size (was 8-18, now 4-10)
    });
  }
function drawHeartArch(x) {
  const screenX = x - cam.x;
  const archRadius = 135;

  ctx.save();
  // A soft pink glow behind the whole cluster
  ctx.shadowBlur = 35;
  ctx.shadowColor = "rgba(255, 79, 134, 0.6)";

  // Loop to create a dense cluster
  // We use 20 steps to make sure there are no gaps
  for (let i = 0; i <= 20; i++) {
    let angle = Math.PI + (i * Math.PI / 20);
    
    // We draw 3 hearts at each angle with different offsets to create "thickness"
    for (let j = 0; j < 3; j++) {
      let offset = (j * 15) - 15; // Creates hearts at -15, 0, and +15 pixels from the center
      let hX = screenX + Math.cos(angle) * (archRadius + offset);
      let hY = groundY + Math.sin(angle) * (archRadius + offset);
      
      // Randomize the size slightly for a natural "clustered" look
      let size = 12 + (i % 3) * 4; 
      
      // Use your reddish-pink color
      ctx.fillStyle = "#ff4f86";
      drawHeart(hX, hY, size);
      
      // Add a tiny white highlight to some hearts for a "shimmer" effect
      if ((i + j) % 5 === 0) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        drawHeart(hX - 2, hY - 2, size * 0.5);
      }
    }
  }

  // 2. THE "FINISH" SIGN
  ctx.shadowBlur = 0;
  ctx.fillStyle = "white";
  ctx.font = "bold 24px system-ui";
  ctx.textAlign = "center";
  // Outline for readability
  ctx.strokeStyle = "#ff4f86";
  ctx.lineWidth = 4;
  ctx.strokeText("FINISH", screenX, groundY - archRadius - 30);
  ctx.fillText("FINISH", screenX, groundY - archRadius - 30);
  
  ctx.restore();
}
  function init() {
    player = { x: 60, y: groundY - 44, r: 22, vx: baseSpeed, vy: 0, onGround: true, alive: true, rotation: 0 };
    cam = { x: 0 };
    hearts = [];
    fireworks = [];
    checkpointState = CHECKPOINTS.map(cp => ({ ...cp, hit: false }));
    
    obstacles = [];
    let nextX = 700;
    while (nextX < finishX - 500) {
      const progress = nextX / finishX; 
      const nearCP = CHECKPOINTS.some(cp => Math.abs(nextX - cp.x) < 300);
      if (!nearCP) {
        const roll = Math.random();
        if (progress > 0.8 && roll < 0.35) {
          const tGap = 210;
          obstacles.push({ x: nextX, y: groundY - 35, w: 35, h: 35 });
          obstacles.push({ x: nextX + tGap, y: groundY - 35, w: 35, h: 35 });
          obstacles.push({ x: nextX + (tGap * 2), y: groundY - 35, w: 35, h: 35 });
          nextX += (tGap * 2);
        } else if (progress > 0.2 && roll < 0.4) {
          obstacles.push({ x: nextX, y: groundY - 35, w: 35, h: 35 });
          obstacles.push({ x: nextX + 180, y: groundY - 35, w: 35, h: 35 });
          nextX += 180;
        } else {
          const isTall = Math.random() < 0.3; 
          obstacles.push({ x: nextX, y: isTall ? groundY - 70 : groundY - 35, w: 35, h: isTall ? 70 : 35 });
        }
      }
      const gapBase = 500 - (progress * 300); 
      nextX += gapBase + (Math.random() * 100);
    }
  }

  function drawPalmTree(x, y, isHit) {
    ctx.save();
    if (isHit) {
        ctx.shadowBlur = 25;
        ctx.shadowColor = "#ff7aa2";
    }

    // Segmented Trunk (The "Bumpy" look)
    ctx.fillStyle = isHit ? "#5D3A1A" : "#8B4513";
    for (let i = 0; i < 11; i++) {
        let segmentY = y - (i * 8);
        let segmentX = x + Math.sin(i * 0.2) * 6; 
        ctx.beginPath();
        ctx.ellipse(segmentX, segmentY, 8 - (i * 0.4), 6, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Thick Leaf Canopy
    const leafColor = isHit ? "#ff7aa2" : "#2E8B57";
    const trunkTopX = x + Math.sin(10 * 0.2) * 6;
    const trunkTopY = y - 88;

    ctx.fillStyle = leafColor;
    for (let i = 0; i < 6; i++) {
        ctx.save();
        ctx.translate(trunkTopX, trunkTopY);
        ctx.rotate((i * 60 + 30) * Math.PI / 180); 
        ctx.beginPath();
        ctx.ellipse(20, 0, 25, 8, 0.1, 0, Math.PI * 2);
        ctx.fill();
        // Leaf Spine
        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0,0); ctx.lineTo(35, 0); ctx.stroke();
        ctx.restore();
    }
    ctx.restore();
  }

  function drawCoconutPlayer(px, py, r, rotation, alive) {
    ctx.save();
    ctx.translate(px + r, py + r);
    ctx.rotate(rotation);
    ctx.fillStyle = alive ? "#5d3a1a" : "#3d2a1a";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(-8, -2, 6, 0, 7); ctx.fill();
    ctx.beginPath(); ctx.arc(8, -2, 6, 0, 7); ctx.fill();
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(-8, -2, 3, 0, 7); ctx.fill();
    ctx.beginPath(); ctx.arc(8, -2, 3, 0, 7); ctx.fill();
    ctx.fillStyle = "#ff4f86";
    ctx.beginPath(); ctx.ellipse(-9, -r+2, 7, 5, 0.8, 0, 7); ctx.fill();
    ctx.beginPath(); ctx.ellipse(1, -r+2, 7, 5, -0.8, 0, 7); ctx.fill();
    ctx.restore();
  }

  function update() {
    // Inside update()
    if (gameStarted && !paused && player.alive) {
      // Lowering to 0.15 makes the trail look more delicate
      if (Math.random() < 0.15) spawnHeart(player.x, player.y + player.r);
    }
    if (paused || !gameStarted || !player.alive) return;
    const speedBoost = Math.floor(player.x / 1000) * 0.11;
    player.vx = baseSpeed + speedBoost;
    player.vy += 1.2;
    player.y += player.vy;
    player.x += player.vx;
    if(player.onGround) player.rotation += 0.15;
    if (player.y + (player.r * 2) >= groundY) {
      player.y = groundY - (player.r * 2);
      player.vy = 0; player.onGround = true;
    }
    cam.x = player.x - 220;
    // This maps 0 -> 18,000 real distance to 0 -> 2,300 display distance
let displayDist = Math.floor((player.x / finishX) * 2300);
document.getElementById("dist").textContent = displayDist;
    
    // Heart Spawn
    if (Math.random() < 0.2) spawnHeart(player.x + player.r, player.y + player.r);

    // Particles Update
    for (let i = fireworks.length - 1; i >= 0; i--) {
      let h = fireworks[i];
      h.x += h.vx; h.y += h.vy; h.life--;
      if (h.life <= 0) fireworks.splice(i, 1);
    }

    checkpointState.forEach(cp => {
      if (!cp.hit && player.x >= cp.x) {
        cp.hit = true; 
        paused = true;
        document.getElementById("modalTitle").textContent = cp.title;
        document.getElementById("modalText").textContent = cp.text;
        
        // CHANGE BUTTON TEXT HERE
        document.getElementById("modalBtn").textContent = "Continue";
        
        document.getElementById("infoSection").style.display = "none";
        document.getElementById("modal").style.display = "flex";
      }
    });
    obstacles.forEach(ob => {
      const p = 8;
      if (player.x + (player.r*2) > ob.x+p && player.x < ob.x+ob.w-p && player.y + (player.r*2) > ob.y+p && player.y < ob.y+ob.h-p) {
        player.alive = false;
        document.getElementById("modalTitle").textContent = "Cracked! üòâü••";
        document.getElementById("modalText").textContent = "Try again! You can do it.";
        document.getElementById("modal").style.display = "flex";
      }
    });


    // 2. CHECK FOR THE FINISH LINE
    if (player.x >= finishX && !paused) {
      paused = true;
      
      // Fire the heart particles
      for(let i = 0; i < 60; i++) {
        fireworks.push({
          x: player.x, y: player.y,
          vx: (Math.random() * 8 - 4), vy: -5 - Math.random() * 10,
          life: 90, size: 5 + Math.random() * 10
        });
      }

      // 3. DEFINE THE LETTER CONTENT FIRST
      const longLetter = `
        Happy Valentine's Day!<br><br>
        You've just finished 2,300 meters of our journey together, but in reality, I feel like I've known you for a thousand miles. 
        You make every single day feel like a sunset in paradise.<br><br>
        Thank you for being my teammate, my best friend, and my favorite adventure. I love you more than all the stars in this purple sky.<br><br>
        Yours forever,<br>
        [Your Name]
        
        <div class="voucher">
    <div class="coin-container">
        <div class="coin-face">‚òÖ</div>
    </div>
    <h2>VALENTINE'S GIFT COIN</h2>
    <div class="amount">$50</div>
    <p>Good for one amazing date night!</p>
</div>
      `;

      // 4. NOW UPDATE THE MODAL (Since longLetter is now defined)
      document.getElementById("modalTitle").textContent = "My Dearest, ‚ù§Ô∏è";
      
      const textElement = document.getElementById("modalText");
      textElement.innerHTML = `<div class="letter-content">${longLetter}</div>`;
      
      document.getElementById("modalBtn").textContent = "Play Again";
      document.getElementById("infoSection").style.display = "none"; // Clears the icons to make space
      document.getElementById("modal").style.display = "flex";
    }
  }    

  function drawHeart(x, y, s) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - s/2, x - s, y - s/2, x - s, y);
    ctx.bezierCurveTo(x - s, y + s/2, x, y + s, x, y + s);
    ctx.bezierCurveTo(x, y + s, x + s, y + s/2, x + s, y);
    ctx.bezierCurveTo(x + s, y - s/2, x, y - s/2, x, y);
    ctx.fill();
  }

  function draw() {
    // 1. SKY
    const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
    skyGrad.addColorStop(0, "#4a148c"); skyGrad.addColorStop(1, "#ff7043");
    ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, W, H);

    // 2. INFINITE HEART CLOUDS
    ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
    for(let i = 0; i < 20; i++) {
        let heartX = ((i * 800 - cam.x * 0.1) % (W + 800)) - 100;
        if (heartX < -100) heartX += (W + 800);
        drawHeart(heartX, 50 + (i * 30) % 200, 20);
    }

    // 3. OCEAN
    const oceanGrad = ctx.createLinearGradient(0, groundY - 45, 0, groundY);
    oceanGrad.addColorStop(0, "#4fc3f7"); oceanGrad.addColorStop(1, "#0288d1");
    ctx.fillStyle = oceanGrad; ctx.fillRect(0, groundY - 45, W, 45);
    // REFINED SUBTLE WATER GLOW
    ctx.fillStyle = "rgba(255, 255, 255, 0.12)"; // Lowered from 0.2 to 0.12
    for (let i = 0; i < 6; i++) {
        // Slower drift (0.0006) and less horizontal movement
        let driftX = (Math.sin(Date.now() * 0.0006 + i) * 30) + (i * 180 - cam.x * 0.05) % W;
        if (driftX < 0) driftX += W;
        
        // Keep highlights closer to the horizon line
        let driftY = groundY - 38 + (i % 2) * 8;
        
        ctx.beginPath();
        // Thinner, longer ellipses for a flatter water look
        ctx.ellipse(driftX, driftY, 45, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // 4. SAND
    const sandGrad = ctx.createLinearGradient(0, groundY, 0, H);
    sandGrad.addColorStop(0, "#ffe082"); sandGrad.addColorStop(1, "#c7a54b");
    ctx.fillStyle = sandGrad; ctx.fillRect(0, groundY, W, H - groundY);

    // Inside draw()
    // 4.5 FINISH LINE (Appears when you're within 1500m)
    if (finishX - player.x < 1500) {
      drawHeartArch(finishX);
    }

    // 5. CHECKPOINTS
    checkpointState.forEach(cp => drawPalmTree(cp.x - cam.x, groundY, cp.hit));

   // 6. STYLIZED GLASSY OBSTACLES
    obstacles.forEach(ob => {
      const ox = ob.x - cam.x;
      // Shadow
      ctx.fillStyle = "rgba(0,0,0,0.15)";
      ctx.fillRect(ox + 4, ob.y + 4, ob.w, ob.h);

      // Main Pink Body with Gradient
      const obGrad = ctx.createLinearGradient(ox, ob.y, ox + ob.w, ob.y + ob.h);
      obGrad.addColorStop(0, "#ff4f86");
      obGrad.addColorStop(1, "#d81b60");
      ctx.fillStyle = obGrad;
      ctx.fillRect(ox, ob.y, ob.w, ob.h);
      
      // Top Highlight & Gloss Streak
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.fillRect(ox, ob.y, ob.w, 4);
      ctx.fillStyle = "rgba(255,255,255,0.1)";
      ctx.fillRect(ox + (ob.w * 0.2), ob.y, ob.w * 0.1, ob.h);
    });

    

    // 7. PLAYER
    drawCoconutPlayer(player.x - cam.x, player.y, player.r, player.rotation, player.alive);

  // 8. REFINED HEART PARTICLES
    fireworks.forEach(h => {
      ctx.save();
      // A more reddish-pink (DeepPink/Crimson hue)
      ctx.fillStyle = `rgba(255, 20, 100, ${h.life / 50})`; 
      drawHeart(h.x - cam.x, h.y, h.size);
      ctx.restore();
    });

    requestAnimationFrame(draw);
  }

  document.getElementById("modalBtn").addEventListener("click", () => {
    const music = document.getElementById("bgMusic");

    // Set volume here (0.3 is usually a nice background level)
    music.volume = 0.15;

    if (music.paused) music.play().catch(e => console.log("Audio blocked"));
    
    document.getElementById("modal").style.display = "none";
    
    if (!player.alive || player.x >= finishX) {
        // Reset the modal content for the next time it pops up
        document.getElementById("infoSection").style.display = "grid"; 
        document.getElementById("modalText").innerHTML = "A virtual letter for you love";
        init();
    }
    
    paused = false; 
    gameStarted = true;
});

  // KEYBOARD JUMP
  window.addEventListener("keydown", (e) => {
    if ((e.code === "Space" || e.code === "ArrowUp") && player.onGround && !paused) {
      player.vy = -16; 
      player.onGround = false;
    }
  });

  // MOBILE TOUCH JUMP
  window.addEventListener("touchstart", (e) => {
    // If the game is running and not paused, jump!
    if (player.onGround && !paused && gameStarted) {
      player.vy = -16; 
      player.onGround = false;
      
      // This prevents the screen from bouncing/scrolling while playing
      if (e.target.id !== "modalBtn") { 
          e.preventDefault(); 
      }
    }
  }, { passive: false });

  init();
  document.getElementById("modalText").textContent = "A virtual letter for you my love";
  setInterval(update, 1000/60);
  draw();
})();
</script>
<audio id="bgMusic" loop>
  <source src="https://files.catbox.moe/hq4kc4.mp3" type="audio/mpeg">
</audio>
</body>
</html>
